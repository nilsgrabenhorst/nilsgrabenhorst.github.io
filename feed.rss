<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>saiboi</title><description>A blog about software engineering in the Swift world</description><link>https://saiboi.com</link><language>en</language><lastBuildDate>Wed, 1 Oct 2025 16:06:16 +0200</lastBuildDate><pubDate>Wed, 1 Oct 2025 16:06:16 +0200</pubDate><ttl>250</ttl><atom:link href="https://saiboi.com/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://saiboi.com/blog/NonCopyable</guid><title>Noncopyable Types</title><description>Non-Copyable types for safety and profit.</description><link>https://saiboi.com/blog/NonCopyable</link><pubDate>Sun, 28 Sep 2025 19:21:00 +0200</pubDate><content:encoded><![CDATA[<h1>Noncopyable Types</h1><h3>The Copyable Protocol</h3><p>Swift 5.9 introduced the <code>Copyable</code> protocol for types that can be copied. Every type is <code>Copyable</code> by default, so we do not need to explicitly adopt this protocol. Of course types could alredy be copied in earlier versions of Swift, long before <code>Copyable</code> was introduced. In fact, Swift creates copies all the time. After all, this is the first thing we all learned about value types, right?</p><pre><code><span class="keyword">struct</span> Food {
    <span class="keyword">var</span> value: <span class="type">String</span>
}

<span class="keyword">let</span> food = <span class="type">Food</span>(value: <span class="string">"üçè"</span>)

<span class="comment">// assigning it again implicitly creates a copy of a value type</span>
<span class="keyword">var</span> copiedFood = food

<span class="comment">// updates of the copy don't affect the original:</span>
copiedFood.<span class="property">value</span> = <span class="string">"üçä"</span>

<span class="comment">// prints "original: üçè, copied: üçä"</span>
<span class="call">print</span>(<span class="string">"original:</span> \(food.<span class="property">value</span>)<span class="string">, copied:</span> \(copiedFood.<span class="property">value</span>)<span class="string">"</span>)
</code></pre><p>That's exactly the behavior of <code>Copyable</code>. And since everyting conforms by default, code still behaves the same. What's new? We can opt out.</p><h3>Noncopyable Types</h3><p>To remove the implicit <code>Copyable</code> conformance from a type, we add <code>~Copyable</code> to the list of conformances. Usually we pronounce the tilde as "non-", as in "noncopyable". After opting out we get guaranteed unique ownership of the value. It cannot be copied anymore.</p><pre><code><span class="keyword">struct</span> Credential: ~<span class="type">Copyable</span> {
    <span class="keyword">var</span> password: <span class="type">String</span>
}

<span class="comment">// We cannot re-assign a global noncopyable value.
// A copy cannot be created. And the compiler cannot guarantee that nobody uses the
// original global `credential` property after it was assigned to `theSameCredential`:</span>
<span class="keyword">let</span> credential = <span class="type">Credential</span>(password: <span class="string">"secret"</span>)
<span class="keyword">let</span> theSameCredential = credential <span class="comment">// ‚ùå Cannot consume noncopyable stored property 'credential' that is global

// we can re-assign local noncopyable values...</span>
<span class="keyword">func</span> test() {
    <span class="keyword">let</span> credential = <span class="type">Credential</span>(password: <span class="string">"secret"</span>)
    <span class="call">print</span>(credential.<span class="property">password</span>) <span class="comment">// ‚úÖ OK here</span>
    
    <span class="keyword">let</span> credentialCopy = credential <span class="comment">// The original `credential` is "consumed" here. We are not allowed to use it afterwards.</span>
    <span class="call">print</span>(credential.<span class="property">password</span>) <span class="comment">// ‚ùå 'credential' used after consume</span>
}
</code></pre><h3>Using Noncopyable Types</h3><p>When calling a function, its arguments are automatically copied. Obviously that won't work for <code>~Copyable</code> parameters. We need to tell the compiler what should happen to a noncopyable argument. Such an argument guarantees unique ownership, so we need to decide whether the function should <em>borrow</em> ownership while it is running, or whether it should take ownership away from the caller by <em>consuming</em> the value.</p><pre><code><span class="keyword">func</span> inspect(<span class="keyword">_</span> credential: borrowing <span class="type">Credential</span>) {
    <span class="call">print</span>(<span class="string">"The password is:"</span>, credential.<span class="property">password</span>)
}

<span class="keyword">func</span> logIn(<span class="keyword">_</span> credential: consuming <span class="type">Credential</span>) {
    <span class="call">print</span>(<span class="string">"Logged in with password:</span> \(credential.<span class="property">password</span>)<span class="string">"</span>)
}

<span class="keyword">func</span> test() {
    <span class="keyword">let</span> credential = <span class="type">Credential</span>(password: <span class="string">"secret"</span>)
    
    <span class="comment">// `inspect()` borrows `credential`.
    // `test()` maintains ownership when `inspect()` returns, so `credential can be used again.</span>
    <span class="call">inspect</span>(credential)
    
    <span class="comment">// `logIn()` takes ownership by consuming `credential`.
    // The `credential` in `test()` cannot be used anymore.</span>
    <span class="call">logIn</span>(credential)
    
    <span class="call">inspect</span>(credential) <span class="comment">// ‚ùå 'credential' used after consume</span>
}
</code></pre><p>We cannot mutate a borrowed value, it's read-only. Do you remember <code>inout</code> parameters? For <code>Copyable</code> types, the value is copied into a local mutable property. It will be written back to the original place when the function returns. We can use <code>inout</code> parameters wit noncopyable types too! Of course, the value is not copied and written back. Instead, any mutations are applied directly to the original location of the value's data. <code>inout</code> parameters essentially behave like mutatable <code>borrowing</code> parameters.</p><pre><code><span class="keyword">func</span> update(<span class="keyword">_</span> credential: <span class="keyword">inout</span> <span class="type">Credential</span>, newPassword: <span class="type">String</span>) {
    credential.<span class="property">password</span> = newPassword
}

<span class="keyword">func</span> test2() {
    <span class="keyword">var</span> credential = <span class="type">Credential</span>(password: <span class="string">"secret"</span>)
    <span class="call">update</span>(&amp;credential, newPassword: <span class="string">"12345"</span>)
    
    <span class="comment">// we still have ownership of `credentials`, so we can use it:</span>
    <span class="call">print</span>(<span class="string">"Updated passsword:"</span>, credential.<span class="property">password</span>) <span class="comment">// prints "Updated passsword: 12345"</span>
}
</code></pre><h2>Motivation</h2><p>Copyable types are much simpler to use. We need to add ownership annotations for noncopyable types. And noncopyable types can spread virally if we don't use them carefully, because any value type with noncopyable properties needs to be noncopyable as well. This makes sense ‚Äî how would you create a copy of something if you are not allowed to copy some of its parts?</p><p>Copying takes some small amount of processing time. And they consume some memory. This does not matter much in most circumstances because copying is quite efficient. Many larger value types use the Copy-on-Write strategy as an optimization to avoid creating unnecessary copies<sup id=fnr1-2025-09-28><a href="#fn1-2025-09-28">1</a></sup>.</p><p><code>~Copyable</code> is a tool for <strong>performance-critical code</strong>. Code where a tight loop is too slow due to excessive copying. Or code that runs in a constrained environment, for example <a href="https://www.swift.org/get-started/embedded/">embedded systems</a>.</p><p>We can also use <code>~Copyable</code> to make sure our code is <strong>correct</strong> and <strong>safe</strong>. Creating accidental copies may be very dangerous for some values. Can you think of any examples?</p><ul><li><strong>Credentials</strong>: In a login flow we want to make sure the user-entered password does not leak out somehow. We can wrap the string in a non-copyable <code>Credential</code> type. The method for logging in <em>consumes</em> this value. Since swift guarantees unique ownership, we can be confident that this value does not accidentally leak out between creation and consumption. For example, the credential cannot be logged or printed anymore.</li></ul><ul><li><strong>Transactions</strong> in a banking app: Withdrawals and deposits can be modeled as a <code>Transaction</code> to be applied to an account. A customer would be very upset if a withdrawal transaction would be applied twice because the value was accidentally copied somewhere. A noncopyable <code>Transaction</code> prevents this class of bugs at compile time.</li></ul><ul><li><strong>File handles</strong>: A noncopyable file handle ensures unique ownership. This prevents bugs like accidentally closing a file multiple times. We can close the file handle in the type's <code>deinit</code>, which is guaranteed to run only once.</li></ul><p>Let's explore a small credentials example:</p><pre><code><span class="keyword">struct</span> Credential: ~<span class="type">Copyable</span> {
    <span class="keyword">let</span> user: <span class="type">String</span>
    
    <span class="comment">// The password should be private.
    // The only way to read it is via a consuming method.</span>
    <span class="keyword">private let</span> password: <span class="type">String</span>
    
    <span class="keyword">init</span>(user: <span class="type">String</span>, password: <span class="type">String</span>) {
        <span class="keyword">self</span>.<span class="property">user</span> = user
        <span class="keyword">self</span>.<span class="property">password</span> = password
    }
    
    consuming <span class="keyword">func</span> getPassword() -&gt; <span class="type">String</span> {
        <span class="keyword">return</span> password
    }
}

<span class="keyword">enum</span> Account {
    <span class="keyword">case</span> loggedOut
    <span class="keyword">case</span> loggedIn(user: <span class="type">String</span>)
    
    <span class="keyword">init</span>() {
        <span class="keyword">self</span> = .<span class="dotAccess">loggedOut</span>
    }
    
    <span class="keyword">mutating func</span> logIn(<span class="keyword">_</span> credential: consuming <span class="type">Credential</span>) <span class="keyword">throws</span> {
        <span class="keyword">let</span> user = credential.<span class="property">user</span>
        <span class="keyword">let</span> password = credential.<span class="call">getPassword</span>() <span class="comment">// credential is consumed here.
        
        // if password is wrong, throw an error
        // else</span>
        <span class="keyword">self</span> = .<span class="call">loggedIn</span>(user: user)
    }
}

<span class="keyword">func</span> test() {
    <span class="keyword">var</span> account = <span class="type">Account</span>()
    <span class="keyword">let</span> credential = <span class="type">Credential</span>(user: <span class="string">"m√∂pelk√∂tter"</span>, password: <span class="string">"secret"</span>)
    
    <span class="comment">// we cannot accidentally leak the password in the chain between
    // creating the credential and consuming it when logging in.
    // If we try, we get a compiler error:</span>
    <span class="call">print</span>(credential.<span class="call">getPassword</span>()) <span class="comment">// ‚ùå 'credential' consumed more than once</span>
    
    <span class="keyword">try</span>? account.<span class="call">logIn</span>(credential)
    <span class="call">print</span>(account)
}
</code></pre><h2>Protocols, Generics, Deinit, Discard</h2><p>We can use noncopyable types as generic arguments since Swift 6<sup id=fnr2-2025-09-28><a href="#fn2-2025-09-28">2</a></sup>. We can also add protocol conformances to noncopyable types. However, protocols implicitly require <code>Copyable</code> conformance by default: <code>protocol P {}</code> is shorthand for <code>protocol P: Copyable {}</code>. We cannot add conformance to <code>P</code> to a noncopyable type unless we remove <code>Copyable</code> from the protocol using <code>~Copyable</code>:</p><pre><code><span class="keyword">protocol</span> P: ~<span class="type">Copyable</span> {}
</code></pre><p>Careful though! This does not mean that all types conforming to <code>P</code> must be noncopyable, or that those types automatically become noncopyable. It just removes the <code>Copyable</code> requirement from the protocol, so that <code>P</code> conformance can be added to both <code>Copyable</code> and noncopyable types:</p><pre><code><span class="keyword">protocol</span> A {}
<span class="keyword">protocol</span> B: ~<span class="type">Copyable</span> {}

<span class="comment">// `B` does not require `Copyable` conformance, but this type is still `Copyable:</span>
<span class="keyword">struct</span> C: <span class="type">B</span> {}

<span class="comment">// This type cannot be copied, and `B` does not care:</span>
<span class="keyword">struct</span> NC: <span class="type">B</span>, ~<span class="type">Copyable</span> {}

<span class="comment">// Noncopyable types cannot conform to protocols that require `Copyable`:</span>
<span class="keyword">extension</span> <span class="type">NC</span>: <span class="type">A</span> {} <span class="comment">// ‚ùå Type 'NC' does not conform to protocol 'Copyable'</span>
</code></pre><p>Let's explore a more concrete example. We start with an <code>Account</code> actor that keeps track of the account's balance:</p><pre><code><span class="keyword">actor</span> Account {
    <span class="keyword">private(set) var</span> balance: <span class="type">Int</span> = <span class="number">0</span>
}
</code></pre><p>We want to be able to add or remove funds. We model this as applying a <code>Transaction</code>. It's a good idea to to make transactions noncopyable. This prevents bugs caused by accidentally applying a transaction twice.</p><p>For some reason<sup id=fnr3-2025-09-28><a href="#fn3-2025-09-28">3</a></sup> we decide to write two different transaction types, <code>Deposit</code> and <code>Withdrawal</code>. Both conform to a <code>Transaction</code> protocol:</p><pre><code><span class="comment">// Transactions are allowed to be noncopyable</span>
<span class="keyword">protocol</span> Transaction: ~<span class="type">Copyable</span> {
    
    <span class="comment">// an implementation may be, but is not required to be `consuming`.</span>
    consuming <span class="keyword">func</span> use() -&gt; <span class="type">Int</span>
}

<span class="keyword">struct</span> Deposit {
    <span class="keyword">private let</span> amount: <span class="type">UInt</span>
    
    <span class="keyword">init</span>(amount: <span class="type">UInt</span>) {
        <span class="keyword">self</span>.<span class="property">amount</span> = amount
    }
}

<span class="keyword">struct</span> Withdrawal: ~<span class="type">Copyable</span> {
    <span class="keyword">private let</span> amount: <span class="type">UInt</span>
    
    <span class="keyword">init</span>(amount: <span class="type">UInt</span>) {
        <span class="keyword">self</span>.<span class="property">amount</span> = amount
    }
    
    <span class="comment">// noncopyable structs may have a deinitializer.
    // We can use it to log a message.</span>
    <span class="keyword">deinit</span> {
        <span class="call">print</span>(<span class="string">"Withdrawal deinitialized before used."</span>)
    }
}
</code></pre><p>‚ö†Ô∏è Did you notice that <code>Deposit</code> is <code>Copyable</code>? Uh-oh!!! üö®</p><p>Time to add <code>Transaction</code> conformances:</p><pre><code><span class="comment">// üí™ Yes, we can!
// (conform to `Transaction`, even though `Deposit` is `Copyable`)</span>
<span class="keyword">extension</span> <span class="type">Deposit</span>: <span class="type">Transaction</span> {
    <span class="keyword">func</span> use() -&gt; <span class="type">Int</span> {
        <span class="keyword">return</span> <span class="type">Int</span>(amount)
    }
}

<span class="keyword">extension</span> <span class="type">Withdrawal</span>: <span class="type">Transaction</span> {
    <span class="comment">// The protocol allows us to make this method `consuming`.
    // We don't have to, but we want this behavior to prevent
    // using a transaction twice.</span>
    consuming <span class="keyword">func</span> use() -&gt; <span class="type">Int</span> {
        <span class="keyword">let</span> value = -<span class="type">Int</span>(amount)
        
        <span class="comment">// We log a message when this transaction is used:</span>
        <span class="call">print</span>(<span class="string">"Withdrawal used."</span>)
        
        <span class="comment">// ...but we don't want to log the default message in `deinit`.
        // `discard` prevents `deinit` from running:</span>
        discard <span class="keyword">self
        
        return</span> value
    }
}
</code></pre><p>Great! Now we can add a generic method that applies some <code>Transaction</code> to an account:</p><pre><code><span class="keyword">extension</span> <span class="type">Account</span> {
    <span class="keyword">func</span> apply(<span class="keyword">_</span> transaction: consuming <span class="keyword">some</span> <span class="type">Transaction</span> &amp; ~<span class="type">Copyable</span>) {
        <span class="keyword">let</span> value = transaction.<span class="call">use</span>()
        balance += value
    }
}
</code></pre><p>A more traditional way to spell the generic argument is <code>func apply&lt;T: Transaction &amp; ~Copyable&gt;(_ transaction: consuming T) {...}</code>. In both cases the meaning is the same: The argument has to be a <code>Transaction</code>, but it does not need to be <code>Copyable</code>. By default, all generic arguments require <code>Copyable</code> conformance; we use <code>~Copyable</code> to remove this implicit requirement. In practice, we can now call this method with both copyable and noncopyable transactions.</p><p>Let's try it out:</p><pre><code><span class="type">Task</span> {
    <span class="keyword">let</span> account = <span class="type">Account</span>()
    
    <span class="keyword">let</span> deposit = <span class="type">Deposit</span>(amount: <span class="number">100</span>)
    <span class="keyword">await</span> account.<span class="call">apply</span>(deposit)
    
    <span class="keyword">let</span> withdrawal = <span class="type">Withdrawal</span>(amount: <span class="number">50</span>)
    <span class="keyword">await</span> account.<span class="call">apply</span>(withdrawal) <span class="comment">// prints: "Withdrawal used."
    
    // ‚ö†Ô∏è Bug: We apply the same transaction twice!!! üôÄ</span>
    <span class="keyword">await</span> account.<span class="call">apply</span>(deposit)
    
    <span class="keyword">await</span> <span class="call">print</span>(<span class="string">"Current balance:"</span>, account.<span class="property">balance</span>) <span class="comment">// prints: "Current balance: 150" ‚Äî That's too much by 100.
    
    // Withdrawals are noncopyable, so we cannot apply it twice:</span>
    <span class="keyword">await</span> account.<span class="call">apply</span>(withdrawal) <span class="comment">// ‚ùå 'withdrawal' consumed more than once</span>
    
    <span class="keyword">let</span> anotherWithdrawal = <span class="type">Withdrawal</span>(amount: <span class="number">42</span>)
    
    <span class="comment">// anotherWithdrawal will be cleaned up at the end of the scope if not
    // consumed otherwise. We would see the message from its `deinit`
    // after "End of demo". Sometimes we want tighter control. We can explicitly
    // `consume` a value. Its memory is freed immediately and the compiler
    // prevents usage afterwards:</span>
    consume anotherWithdrawal <span class="comment">// prints: "Withdrawal deinitialized before used."</span>
    
    <span class="call">print</span>(<span class="string">"End of demo"</span>)
}
</code></pre><h2>Conclusion</h2><p><code>~Copyable</code> is an exciting tool in our belt, for fine-grained ownership control, improved efficiency, and to make sure our code is correct. However, we have to be careful: when using <code>~Copyable</code> with protocols and generics, it does not prescribe noncopyability. Instead, it just opts the protocol or generic out of the requirement to be <code>Copyable</code>.</p><p>Have you used noncopyable types, or do you have new ideas how to use them? I'd love to hear from you <a href="https://mastodon.social/@saiboi">on Mastodon</a>!</p><div class="footnotes">
<hr>
<ol>

<li id="fn1-2025-09-28"><p>
Examples for CoW (Copy-on-Write) types are Collections (`Array`, `Dictionary`, `Set`), `String`, and `Data`. The struct itself is still copied, but the potentially very large amount of data is stored outside of the struct in a reference-counted buffer. For each copy of the struct, the buffer is not copied. Instead, its refernece count is incremened. This way we end up with multiple copies of the struct, each one pointing to the same buffer. This is safe and keeps value semantics as long as nobody writes to the buffer. Writing is only safe, if there is only one reference to the buffer. CoW types check if the buffer is uniquely referenced before writing ‚Äî if not, the buffer is copied. We can create custom CoW types using <a href="https://developer.apple.com/documentation/swift/isknownuniquelyreferenced(_:)-98zpp" target="_blank">isKnownUniquelyReferenced(_:)</a>.
<a href="#fnr1-2025-09-28" class="footnoteBackLink" title="Jump back to footnote 1 in the text.">‚Ü©Ô∏éÔ∏é</a>
</p></li>

<li id="fn2-2025-09-28"><p>
See <a href="https://github.com/swiftlang/swift-evolution/blob/main/proposals/0427-noncopyable-generics.md" target="_blank">proposal on Swift Evolution</a>
<a href="#fnr2-2025-09-28" class="footnoteBackLink" title="Jump back to footnote 2 in the text.">‚Ü©Ô∏éÔ∏é</a>
</p></li>

<li id="fn3-2025-09-28"><p>
Of course the reason is to demo protocols and generics for noncopyable types! ü§ì
<a href="#fnr3-2025-09-28" class="footnoteBackLink" title="Jump back to footnote 3 in the text.">‚Ü©Ô∏éÔ∏é</a>
</p></li>

</ol>
</div>]]></content:encoded></item><item><guid isPermaLink="true">https://saiboi.com/blog/Simplified%20ViewController</guid><title>Simplified View Controller</title><description>View Controllers can be so simple! They should not contain view-related code like styling or constraint setting. They certainly should not deal with business logic. In fact, we can connect IBOutlets and IBActions directly to classes. Read on to find out how!</description><link>https://saiboi.com/blog/Simplified%20ViewController</link><pubDate>Wed, 26 Mar 2025 18:23:00 +0100</pubDate><content:encoded><![CDATA[<h1>Simplified View Controller</h1><h2>Motivation</h2><p>A common topic in discussions about iOS software architecture is the issue of massive View Controllers. There seems to be a notion that the Model-View-Controller architecture is to blame. But is it really? Maybe the problem stems from a common misunderstanding of the three layers of MVC. The thinking might be:</p><blockquote><p>Where do we place our business logic? Obviously, it's not View code, since we don't display it on screen. And it‚Äôs definitely not Model code, because Model is for our database and entities. Therefore, business logic must be implemented in the Controller.</p></blockquote><p>In my opinion, the <em>Model</em> is actually everything that is not related to the <em>View</em>. It's the right place for business logic and networking. In fact, most of an app's code should be <em>Model</em> code. Since that‚Äôs a lot, it's a good idea to further refine the architectural structure within the <em>Model</em>.</p><p><em>View</em> code should be simple to place. However, I have seen so many projects where <em>View</em> code is implemented in the ViewController: Fonts and colors are set. Constraints are defined. Views are added, shown, hidden, or removed. Constraints are set. Animations are performed. That‚Äôs a lot of code. No wonder ViewControllers are massive! The reason for this may be another misunderstanding:</p><blockquote><p>The <em>view</em> property of a <em>UIViewController</em> is of type <em>UIView!</em>. This implies that I cannot subclass it. Plus, I am using a storyboard, so the view is out of my control anyway. Therefore, all my styling code needs to be in the ViewController class.</p></blockquote><p>Of course, this is wrong. In fact, we can absolutely create a subclass for the <code>view</code>, and we should. A custom view subclass is the perfect place for styling, constraints, and animations. Custom view classes play very well with storyboards; just remember to set the custom class property in the Identity Inspector.</p><p>If we move <em>Model</em> code (business logic, networking, ...) and <em>View</em> code (styling, constraints, animations, ...) out of <em>Controller</em>s, they will become tiny. The only code left in the controller should be code related to lifecycle (<code>viewWillAppear</code>, <code>viewDidDisappear</code>, and the like) and maybe some navigation logic.</p><h2>Refactoring</h2><p>Let's investigate using a tiny sample project. We start with a screen that displays a number. There are buttons for incrementing and decrementing that number. Even though the model has been separated out into its own class, the viewController is quite <em>massive</em>. Can you spot the code related to view styling and business logic?</p><pre><code><span class="keyword">class</span> CounterViewController: <span class="type">UIViewController</span> {
    <span class="keyword">let</span> model = <span class="type">Dependencies</span>.<span class="property">model</span>
    <span class="keyword">private var</span> cancellables: <span class="type">Set</span>&lt;<span class="type">AnyCancellable</span>&gt; = []
    
    <span class="keyword">override func</span> viewDidLoad() {
        <span class="keyword">super</span>.<span class="call">viewDidLoad</span>()
        <span class="call">bind</span>(view)
    }
    
    <span class="comment">// MARK: - Outlets</span>
    
    <span class="keyword">@IBOutlet private weak var</span> label: <span class="type">UILabel</span>!
    <span class="keyword">@IBOutlet private weak var</span> infoLabel: <span class="type">UILabel</span>!
    
    <span class="comment">// MARK: - Actions</span>
    
    <span class="keyword">@IBAction func</span> increment() {
        model.<span class="call">increment</span>()
    }
    
    <span class="keyword">@IBAction func</span> decrement() {
        model.<span class="call">decrement</span>()
    }
    
    <span class="comment">// MARK: - Private</span>
    
    <span class="keyword">private func</span> bind(<span class="keyword">_</span> view: <span class="type">UIView</span>) {
        model.<span class="property">$value</span>
            .<span class="call">sink</span> { [<span class="keyword">weak self</span>] count <span class="keyword">in
                guard let self else</span> { <span class="keyword">return</span> }
                <span class="keyword">self</span>.<span class="property">label</span>.<span class="property">text</span> = <span class="string">"</span>\(count)<span class="string">"</span>
                <span class="keyword">self</span>.<span class="property">infoLabel</span>.<span class="property">text</span> = count.<span class="call">isMultiple</span>(of: <span class="number">2</span>) ? <span class="string">"Even"</span> : <span class="string">"Odd"</span>
                <span class="keyword">self</span>.<span class="property">label</span>.<span class="property">textColor</span> = <span class="keyword">switch</span> count {
                    <span class="keyword">case</span> <span class="number">0</span>:    .<span class="dotAccess">black</span>
                    <span class="keyword">case</span> <span class="number">1</span>...: <span class="type">UIColor</span>(red: <span class="number">0.1</span>, green: <span class="number">0.7</span>, blue: <span class="number">0.05</span>, alpha: <span class="number">1</span>)
                    <span class="keyword">default</span>:   .<span class="dotAccess">red</span>
                }
                <span class="keyword">self</span>.<span class="call">animateLabel</span>()
            }
            .<span class="call">store</span>(in: &amp;cancellables)
    }
    
    <span class="keyword">private func</span> animateLabel() {
        <span class="type">UIView</span>.<span class="call">animate</span>(withDuration: <span class="number">0.1</span>) {
            <span class="keyword">self</span>.<span class="property">label</span>.<span class="property">transform</span> = <span class="type">CGAffineTransform</span>(scaleX: <span class="number">1.3</span>, y: <span class="number">1.3</span>)
        } completion: { <span class="keyword">_ in</span>
            <span class="type">UIView</span>.<span class="call">animate</span>(withDuration: <span class="number">0.1</span>) {
                <span class="keyword">self</span>.<span class="property">label</span>.<span class="property">transform</span> = .<span class="dotAccess">identity</span>
            }
        }
    }
}
</code></pre><p>Admittedly, this may not look too bad, but we are dealing with a tiny demo example. In real-world scenarios, the complexity of view controllers can get out of control pretty quickly. Let's pick a well-known architectural pattern to simplify our code: MVVM (Model-View-ViewModel).</p><h3>MVVM: Extract Model Code</h3><p>A ViewModel provides properties with data to be displayed by the view. The view should observe changes to stay up-to-date, which makes Combine <code>Publisher</code>s a great choice:</p><pre><code><span class="keyword">final class</span> ViewModel {
    <span class="keyword">private let</span> model = <span class="type">Dependencies</span>.<span class="property">model</span>
    
    <span class="comment">// MARK: - View Properties</span>
    <span class="keyword">lazy private(set) var</span> value = model.<span class="property">$value</span>.<span class="call">map</span> { <span class="string">"</span>\($0)<span class="string">"</span> }
    <span class="keyword">lazy private(set) var</span> info = model.<span class="property">$value</span>.<span class="call">map</span>(infoText)
    <span class="keyword">lazy private(set) var</span> labelColor = model.<span class="property">$value</span>.<span class="call">map</span>(color)
}
</code></pre><p>We implement two action methods for handling user input:</p><pre><code><span class="comment">// MARK: - Actions</span>
<span class="keyword">extension</span> <span class="type">ViewModel</span> {
    <span class="keyword">func</span> increment() {
        model.<span class="call">increment</span>()
    }
    
    <span class="keyword">func</span> decrement() {
        model.<span class="call">decrement</span>()
    }
}
</code></pre><p>Finally, we add a private extension with value mappings for the previously declared <code>info</code> and <code>labelColor</code> properties:</p><pre><code><span class="keyword">private extension</span> <span class="type">ViewModel</span> {
    <span class="keyword">func</span> infoText(for count: <span class="type">Int</span>) -&gt; <span class="type">String</span> {
        count.<span class="call">isMultiple</span>(of: <span class="number">2</span>) ? <span class="string">"Even"</span> : <span class="string">"Odd"</span>
    }
    
    <span class="comment">// Here we actually leak styling-related code into our ViewModel. We
    // should not prescribe color values, but let's run with it for now...</span>
    <span class="keyword">func</span> color(for count: <span class="type">Int</span>) -&gt; <span class="type">UIColor</span> {
        <span class="keyword">switch</span> count {
            <span class="keyword">case</span> <span class="number">0</span>:    .<span class="dotAccess">black</span>
            <span class="keyword">case</span> <span class="number">1</span>...: .<span class="dotAccess">green</span>
            <span class="keyword">default</span>:   .<span class="dotAccess">red</span>
        }
    }
}
</code></pre><p>Our updated ViewController:</p><pre><code><span class="keyword">class</span> CounterViewController: <span class="type">UIViewController</span> {
    <span class="keyword">@IBOutlet private weak var</span> label: <span class="type">UILabel</span>!
    <span class="keyword">@IBOutlet private weak var</span> infoLabel: <span class="type">UILabel</span>!
    
    <span class="keyword">let</span> viewModel = <span class="type">ViewModel</span>()
    <span class="keyword">private var</span> cancellables: <span class="type">Set</span>&lt;<span class="type">AnyCancellable</span>&gt; = []
    
    <span class="keyword">override func</span> viewDidLoad() {
        <span class="keyword">super</span>.<span class="call">viewDidLoad</span>()
        <span class="call">bind</span>(view)
    }
    
    <span class="keyword">@IBAction func</span> increment() {
        viewModel.<span class="call">increment</span>()
    }
    
    <span class="keyword">@IBAction func</span> decrement() {
        viewModel.<span class="call">decrement</span>()
    }
    
    <span class="keyword">private func</span> bind(<span class="keyword">_</span> view: <span class="type">UIView</span>) {
        viewModel.<span class="property">value</span>.<span class="call">sink</span> { [<span class="keyword">weak self</span>] count <span class="keyword">in
            self</span>?.<span class="property">label</span>.<span class="property">text</span> = count
            <span class="keyword">self</span>?.<span class="call">animateLabel</span>()
        }.<span class="call">store</span>(in: &amp;cancellables)
        
        viewModel.<span class="property">info</span>.<span class="call">sink</span> { [<span class="keyword">weak self</span>] info <span class="keyword">in
            self</span>?.<span class="property">infoLabel</span>.<span class="property">text</span> = info
        }.<span class="call">store</span>(in: &amp;cancellables)
        
        viewModel.<span class="property">labelColor</span>.<span class="call">sink</span> { [<span class="keyword">weak self</span>] color <span class="keyword">in
            self</span>?.<span class="property">label</span>.<span class="property">textColor</span> = color
        }.<span class="call">store</span>(in: &amp;cancellables)
    }
    
    <span class="keyword">private func</span> animateLabel() {
        <span class="type">UIView</span>.<span class="call">animate</span>(withDuration: <span class="number">0.1</span>) {
            <span class="keyword">self</span>.<span class="property">label</span>.<span class="property">transform</span> = <span class="type">CGAffineTransform</span>(scaleX: <span class="number">1.3</span>, y: <span class="number">1.3</span>)
        } completion: { <span class="keyword">_ in</span>
            <span class="type">UIView</span>.<span class="call">animate</span>(withDuration: <span class="number">0.1</span>) {
                <span class="keyword">self</span>.<span class="property">label</span>.<span class="property">transform</span> = .<span class="dotAccess">identity</span>
            }
        }
    }
}
</code></pre><h3>MVVM: Extract View Code</h3><p>Maybe the improvement in code size is a bit disappointing. In fact, there is quite a bit of <em>View</em> code left over. We move the <code>animateLabel</code> method into a new <code>UIView</code> subclass and add properties for the values to be displayed:</p><pre><code><span class="keyword">final class</span> CounterView: <span class="type">UIView</span> {
    <span class="keyword">@IBOutlet private weak var</span> label: <span class="type">UILabel</span>!
    <span class="keyword">@IBOutlet private weak var</span> infoLabel: <span class="type">UILabel</span>!
    
    <span class="keyword">var</span> count: <span class="type">String</span>? {
        <span class="keyword">get</span> { label.<span class="property">text</span> }
        <span class="keyword">set</span> {
            label.<span class="property">text</span> = newValue
            <span class="call">animateLabel</span>()
        }
    }
    
    <span class="keyword">var</span> info: <span class="type">String</span>? {
        <span class="keyword">get</span> { infoLabel.<span class="property">text</span> }
        <span class="keyword">set</span> { infoLabel.<span class="property">text</span> = newValue }
    }
    
    <span class="keyword">var</span> textColor: <span class="type">UIColor</span>? {
        <span class="keyword">get</span> { label.<span class="property">textColor</span> }
        <span class="keyword">set</span> { label.<span class="property">textColor</span> = newValue }
    }
    
    <span class="keyword">private func</span> animateLabel() {
        <span class="type">UIView</span>.<span class="call">animate</span>(withDuration: <span class="number">0.1</span>) {
            <span class="keyword">self</span>.<span class="property">label</span>.<span class="property">transform</span> = <span class="type">CGAffineTransform</span>(scaleX: <span class="number">1.3</span>, y: <span class="number">1.3</span>)
        } completion: { <span class="keyword">_ in</span>
            <span class="type">UIView</span>.<span class="call">animate</span>(withDuration: <span class="number">0.1</span>) {
                <span class="keyword">self</span>.<span class="property">label</span>.<span class="property">transform</span> = .<span class="dotAccess">identity</span>
            }
        }
    }
}
</code></pre><p>We update the ViewController to use the custom view:</p><pre><code><span class="keyword">class</span> CounterViewController: <span class="type">UIViewController</span> {
    <span class="keyword">@IBOutlet private weak var</span> counterView: <span class="type">CounterView</span>!
    
    <span class="keyword">let</span> viewModel = <span class="type">ViewModel</span>()
    <span class="keyword">private var</span> cancellables: <span class="type">Set</span>&lt;<span class="type">AnyCancellable</span>&gt; = []
    
    <span class="keyword">override func</span> viewDidLoad() {
        <span class="keyword">super</span>.<span class="call">viewDidLoad</span>()
        <span class="call">bind</span>(view)
    }
    
    <span class="keyword">@IBAction func</span> increment() {
        viewModel.<span class="call">increment</span>()
    }
    
    <span class="keyword">@IBAction func</span> decrement() {
        viewModel.<span class="call">decrement</span>()
    }
    
    <span class="keyword">private func</span> bind(<span class="keyword">_</span> view: <span class="type">UIView</span>) {
        viewModel.<span class="property">value</span>.<span class="call">sink</span> { [<span class="keyword">weak</span> counterView] count <span class="keyword">in</span>
            counterView?.<span class="property">count</span> = count
        }.<span class="call">store</span>(in: &amp;cancellables)
        
        viewModel.<span class="property">info</span>.<span class="call">sink</span> { [<span class="keyword">weak</span> counterView] info <span class="keyword">in</span>
            counterView?.<span class="property">info</span> = info
        }.<span class="call">store</span>(in: &amp;cancellables)
        
        viewModel.<span class="property">labelColor</span>.<span class="call">sink</span> { [<span class="keyword">weak</span> counterView] color <span class="keyword">in</span>
            counterView?.<span class="property">textColor</span> = color
        }.<span class="call">store</span>(in: &amp;cancellables)
    }
}
</code></pre><p>Our ViewController has been simplified quite nicely now. However, the current version is chock-full of silly boilerplate code that does not do anything. We just observe changes in the <code>viewModel</code> and pass them on to the <code>view</code>. And we receive actions from the <code>view</code> and pass them on to the <code>viewModel</code>. This class does not provide any value at this point. Unfortunately, we cannot fix it... yet.</p><h3>Remove Boilerplate</h3><p>The boilerplate code in the <code>ViewController</code> adds a layer of separation between <code>counterView</code> and <code>viewModel</code>. This is redundant; the role of separating view from model is already provided by the <code>viewModel</code>. It would be nice to remove the ceremony and connect <code>counterView</code> directly to <code>viewModel</code>. There is actually a tool for this purpose: Custom storyboard objects. They are implemented as classes deriving from <code>NSObject</code>. We can add <code>@IBOutlet</code> and <code>@IBAction</code> annotations for storyboard connections.</p><p>For this demo, let's split the <code>ViewModel</code> into two classes. We could keep the <code>ViewModel</code> intact, but splitting it demonstrates a different architectural approach where data flows only in one direction. And the split approach illustrates how to use multiple custom objects in a storyboard.</p><p>The first object is the <code>Presenter</code>, providing current state for the view to display. Data flows unidirectionally from the Model to the View:</p><pre><code><span class="keyword">class</span> Presenter: <span class="type">NSObject</span> {
    <span class="keyword">let</span> model = <span class="type">Dependencies</span>.<span class="property">model</span>
    
    <span class="keyword">@IBOutlet weak var</span> view: <span class="type">CounterViewProtocol</span>? {
        <span class="keyword">didSet</span> {
            <span class="keyword">guard let</span> view <span class="keyword">else</span> { <span class="keyword">return</span> }
            <span class="call">bind</span>(view)
        }
    }
    
    <span class="keyword">lazy private(set) var</span> value = model.<span class="property">$value</span>.<span class="call">map</span> { <span class="string">"</span>\($0)<span class="string">"</span> }
    <span class="keyword">lazy private(set) var</span> info = model.<span class="property">$value</span>.<span class="call">map</span>(infoText)
    <span class="keyword">lazy private(set) var</span> labelColor = model.<span class="property">$value</span>.<span class="call">map</span>(color)
    
    <span class="keyword">private func</span> bind(<span class="keyword">_</span> view: <span class="type">CounterViewProtocol</span>) {
        value.<span class="call">sink</span> { [<span class="keyword">weak</span> view] value <span class="keyword">in</span>
            view?.<span class="property">count</span> = value
        }.<span class="call">store</span>(in: &amp;cancellables)
        
        info.<span class="call">sink</span> { [<span class="keyword">weak</span> view] info <span class="keyword">in</span>
            view?.<span class="property">info</span> = info
        }.<span class="call">store</span>(in: &amp;cancellables)
        
        labelColor.<span class="call">sink</span> { [<span class="keyword">weak</span> view] color <span class="keyword">in</span>
            view?.<span class="property">textColor</span> = color
        }.<span class="call">store</span>(in: &amp;cancellables)
    }
    
    <span class="keyword">func</span> infoText(for count: <span class="type">Int</span>) -&gt; <span class="type">String</span> {
        count.<span class="call">isMultiple</span>(of: <span class="number">2</span>) ? <span class="string">"Even"</span> : <span class="string">"Odd"</span>
    }
    
    <span class="keyword">func</span> color(for count: <span class="type">Int</span>) -&gt; <span class="type">CounterColor</span> {
        <span class="keyword">switch</span> count {
        <span class="keyword">case</span> <span class="number">0</span>:    .<span class="dotAccess">zero</span>
        <span class="keyword">case</span> <span class="number">1</span>...: .<span class="dotAccess">positive</span>
        <span class="keyword">default</span>:   .<span class="dotAccess">negative</span>
        }
    }
    
    <span class="keyword">private var</span> cancellables: <span class="type">Set</span>&lt;<span class="type">AnyCancellable</span>&gt; = []
}
</code></pre><p>The <code>view</code> property is connected to the view in the storyboard via an <code>@IBOutlet</code>. In this case, we don't work with the concrete view class. Instead, the following <code>CounterViewProtocol</code> provides an interface:</p><pre><code><span class="keyword">@objc protocol</span> CounterViewProtocol {
    <span class="keyword">var</span> count: <span class="type">String</span>? { <span class="keyword">get set</span> }
    <span class="keyword">var</span> info: <span class="type">String</span>? { <span class="keyword">get set</span> }
    <span class="keyword">var</span> textColor: <span class="type">CounterColor</span> { <span class="keyword">get set</span> }
}
</code></pre><p>The second class is the <code>Interactor</code>. It receives <code>@IBActions</code> from the view, performs some business logic, and updates the model. Data flows unidirectionally from the view to the model.</p><pre><code><span class="keyword">class</span> Interactor: <span class="type">NSObject</span> {
    <span class="keyword">let</span> model = <span class="type">Dependencies</span>.<span class="property">model</span>
    
    <span class="keyword">@IBAction func</span> increment() {
        <span class="comment">// OK, not a lot of business logic here...</span>
        model.<span class="call">increment</span>()
    }
    
    <span class="keyword">@IBAction func</span> decrement() {
        model.<span class="call">decrement</span>()
    }
}
</code></pre><p>Now we can remove the ViewController boilerplate.<br/> ü•Å <em>drum roll</em> ü•Å<br/> Behold the magnificence of this mighty massive controller:</p><pre><code><span class="keyword">class</span> CounterViewController: <span class="type">UIViewController</span> { }
</code></pre><p>Yes, this is all the controller code needed for this demo app. In fact, we could use a <code>UIViewController</code> instance directly instead of a subclass, but having a separate type for each scene may be useful when debugging.</p><h3>Storyboard Update</h3><p>Before we can test our new code, we need to update the storyboard. First, remove any existing outlet and action connections.</p><h4>Step 1: Set Custom Class of the View</h4><p>By default, the <code>view</code> of a viewController is a <code>UIView</code> instance. We want to make sure that our customized <code>CounterView</code> is created when the view loads. We can do this by setting the custom class in the view's Identity Inspector:</p><img src="https://saiboi.com/blog/simplifiedViewController/customViewClass.png" alt="Set Custom Class in Xcode's Identity Inspector"/><h4>Step 2: Add Custom Objects</h4><p>Drag an <code>Object</code> from the <code>Views Library</code> into your scene. Make sure it is selected. Set the custom <code>Class</code> to <code>Presenter</code> in the <code>Identity Inspector</code>. Repeat this process for the <code>Interactor</code>.</p><img src="https://saiboi.com/blog/simplifiedViewController/viewsLibrary.png" alt="Search for "Object" in Xcode's Views Library"/><h4>Step 3: Connect Outlets</h4><p>Drag an outlet connection from <code>Presenter.view</code> to the <code>CounterView</code>. Connect the <code>label</code> and <code>infoLabel</code> outlets in <code>CounterView</code> to the labels in the storyboard.</p><img src="https://saiboi.com/blog/simplifiedViewController/presenterViewOutlet.png" alt="Search for "Object" in Xcode's Views Library"/><h4>Step 4: Connect Actions</h4><p>Establish the connections between buttons and the <code>Interactor</code>'s <code>@IBAction</code> methods.</p><img src="https://saiboi.com/blog/simplifiedViewController/interactorAction.png" alt="Search for "Object" in Xcode's Views Library"/><p>Build and run!</p><h2>Conclusion</h2><p>Custom Objects in storyboards are a powerful tool to dramatically simplify view controllers. We can connect view models, or interactors and presenters as shown in this demo. Custom objects are created automatically when the scene is loaded from its storyboard. However, this only works for classes with an initializer without any parameters. Any dependencies must be provided by some other means.</p><p>Nib/Xib files for views have an interesting additional feature: Proxy Objects. These are not instantiated automatically when loading the view. We have to manually create these objects and provide them in the <code>options</code> dictionary when loading the nib. This way we have all the freedom to create and configure objects as needed. However, the dictionary-based API is very clunky; see <a href="https://developer.apple.com/documentation/uikit/uinib/instantiate(withowner:options:)" rel="nofollow" target="blank">UINib.instantiate(withOwner:options:)</a>.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://saiboi.com/blog/Labels%20in%20Switch%20Patterns</guid><title>Labels for Switch Patterns</title><description>How to make switching over multiple values more readable.</description><link>https://saiboi.com/blog/Labels%20in%20Switch%20Patterns</link><pubDate>Fri, 7 Mar 2025 16:40:00 +0100</pubDate><content:encoded><![CDATA[<h1>Labels for Switch Patterns</h1><p>We frequently come across scenarios where we need to check multiple values before executing conditional code. These can lead to nested <code>if</code> statements, which are potentially hard to read and maintain. <code>switch</code> statements are a great alternative with multiple advantages: The compiler performs exhaustiveness checking, and powerful pattern matching is more natural than using the rather weird <code>if case</code> syntax. Additionally, a <code>switch</code> statement can be more efficient than chaining multiple conditionals, as the value to be switched over is read once only, unlike once for each individual <code>if</code> condition check.</p><p>It is important to remember that the switch is evaluated in sequential order until a match is found. By strategically ordering the most specific cases at the top, and the more general catch-all cases at the bottom, we can implement some powerful logic in a simple and concise manner. In the following example, we add the most general case where the <code>isAdmin</code> condition is irrelevant at the bottom:</p><pre><code><span class="keyword">switch</span> (isLoggedIn, isAdmin) {
<span class="keyword">case</span> (<span class="keyword">true</span>, <span class="keyword">true</span>):
    <span class="comment">// ...</span>
    
<span class="keyword">case</span> (<span class="keyword">true</span>, <span class="keyword">false</span>):
    <span class="comment">// ...</span>
    
<span class="keyword">case</span> (<span class="keyword">false</span>, <span class="keyword">_</span>):
    <span class="comment">// For logged-out users, we don't care whether they are an admin.</span>
}
</code></pre><p>Great, this works! But let's face it, it's hard to read. Of course, we can figure out what "<code>case (true, false):</code>" in the above example means, but we have to cross-reference the tuple at the top of the <code>switch</code> statement.</p><p>Let's refactor to improve readability. A very powerful tool is to use bespoke <em>types</em> in place of nondescript <code>true</code>/<code>false</code> boolean values. Here is our example rewritten with two <code>enum</code> types specific for each use case:</p><pre><code><span class="keyword">enum</span> SessionState {
  <span class="keyword">case</span> loggedIn, loggedOut
}

<span class="keyword">enum</span> Role {
  <span class="keyword">case</span> admin, user
}

<span class="comment">// elsewhere:</span>

<span class="keyword">switch</span> (sessionState, role) {
<span class="keyword">case</span> (.<span class="dotAccess">loggedIn</span>, .<span class="dotAccess">admin</span>):
    <span class="comment">// do admin stuff</span>

<span class="keyword">case</span> (.<span class="dotAccess">loggedIn</span>, <span class="keyword">_</span>):
    <span class="comment">// do non-admin stuff</span>

<span class="keyword">case</span> (.<span class="dotAccess">loggedOut</span>, <span class="keyword">_</span>):
    <span class="comment">// ask user to log in</span>
</code></pre><p>Nice! Now our code is locally glanceable. Of course, it may be a bit overkill to do this everywhere. Before we look at a more lightweight approach, it's important to consider additional benefits of custom types. When using a boolean <code>isAdmin</code> value, we could later accidentally replace it with some unrelated boolean value, such as <code>isGuestUser</code>. The compiler is happy with this change, and suddenly all guest users are allowed to perform Admin tasks. Oops! With a bespoke <code>Role</code> type, we get compiler errors preventing this bug. Additionally, a boolean value always has exactly two states, which makes it harder to introduce a new role for guest users. But it's easy with our <code>Role</code> type: we just add a new <code>.guest</code> case.</p><p>However, it may be overkill to define custom types if we only use them for a single switch. A more lightweight approach is to use <strong>labels</strong> instead. Let's see how they can provide similar readability benefits:</p><pre><code><span class="keyword">switch</span> (loggedIn: isLoggedIn, isAdmin: isAdmin) {
<span class="keyword">case</span> (loggedIn: <span class="keyword">true</span>, isAdmin: <span class="keyword">true</span>):
    <span class="comment">// do admin stuff</span>
    
<span class="keyword">case</span> (loggedIn: <span class="keyword">true</span>, isAdmin: <span class="keyword">false</span>):
    <span class="comment">// do non-admin stuff</span>
    
<span class="keyword">case</span> (loggedIn: <span class="keyword">false</span>, <span class="keyword">_</span>):
    <span class="comment">// ask user to log in</span>
}
</code></pre><p>Notice how we don't have to write the label for the catch-all underscore pattern in the third <code>case</code>. Of course, we can mix and match the two approaches as needed. In this example, I would probably prefer a custom <code>Role</code> type, and use a label for a boolean <code>loggedIn</code> state.</p>]]></content:encoded></item></channel></rss>