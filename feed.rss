<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>saiboi</title><description>A blog about software engineering in the Swift world</description><link>https://saiboi.com</link><language>en</language><lastBuildDate>Mon, 28 Jul 2025 15:58:13 +0200</lastBuildDate><pubDate>Mon, 28 Jul 2025 15:58:13 +0200</pubDate><ttl>250</ttl><atom:link href="https://saiboi.com/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://saiboi.com/blog/Simplified%20ViewController</guid><title>Simplified View Controller</title><description>View Controllers can be so simple! They should not contain view-related code like styling or constraint setting. They certainly should not deal with business logic. In fact, we can connect IBOutlets and IBActions directly to classes. Read on to find out how!</description><link>https://saiboi.com/blog/Simplified%20ViewController</link><pubDate>Wed, 26 Mar 2025 18:23:00 +0100</pubDate><content:encoded><![CDATA[<h1>Simplified View Controller</h1><h2>Motivation</h2><p>A common topic in discussions about iOS software architecture is the issue of massive View Controllers. There seems to be a notion that the Model-View-Controller architecture is to blame. But is it really? Maybe the problem stems from a common misunderstanding of the three layers of MVC. The thinking might be:</p><blockquote><p>Where do we place our business logic? Obviously, it's not View code, since we don't display it on screen. And it‚Äôs definitely not Model code, because Model is for our database and entities. Therefore, business logic must be implemented in the Controller.</p></blockquote><p>In my opinion, the <em>Model</em> is actually everything that is not related to the <em>View</em>. It's the right place for business logic and networking. In fact, most of an app's code should be <em>Model</em> code. Since that‚Äôs a lot, it's a good idea to further refine the architectural structure within the <em>Model</em>.</p><p><em>View</em> code should be simple to place. However, I have seen so many projects where <em>View</em> code is implemented in the ViewController: Fonts and colors are set. Constraints are defined. Views are added, shown, hidden, or removed. Constraints are set. Animations are performed. That‚Äôs a lot of code. No wonder ViewControllers are massive! The reason for this may be another misunderstanding:</p><blockquote><p>The <em>view</em> property of a <em>UIViewController</em> is of type <em>UIView!</em>. This implies that I cannot subclass it. Plus, I am using a storyboard, so the view is out of my control anyway. Therefore, all my styling code needs to be in the ViewController class.</p></blockquote><p>Of course, this is wrong. In fact, we can absolutely create a subclass for the <code>view</code>, and we should. A custom view subclass is the perfect place for styling, constraints, and animations. Custom view classes play very well with storyboards; just remember to set the custom class property in the Identity Inspector.</p><p>If we move <em>Model</em> code (business logic, networking, ...) and <em>View</em> code (styling, constraints, animations, ...) out of <em>Controller</em>s, they will become tiny. The only code left in the controller should be code related to lifecycle (<code>viewWillAppear</code>, <code>viewDidDisappear</code>, and the like) and maybe some navigation logic.</p><h2>Refactoring</h2><p>Let's investigate using a tiny sample project. We start with a screen that displays a number. There are buttons for incrementing and decrementing that number. Even though the model has been separated out into its own class, the viewController is quite <em>massive</em>. Can you spot the code related to view styling and business logic?</p><pre><code><span class="keyword">class</span> CounterViewController: <span class="type">UIViewController</span> {
    <span class="keyword">let</span> model = <span class="type">Dependencies</span>.<span class="property">model</span>
    <span class="keyword">private var</span> cancellables: <span class="type">Set</span>&lt;<span class="type">AnyCancellable</span>&gt; = []
    
    <span class="keyword">override func</span> viewDidLoad() {
        <span class="keyword">super</span>.<span class="call">viewDidLoad</span>()
        <span class="call">bind</span>(view)
    }
    
    <span class="comment">// MARK: - Outlets</span>
    
    <span class="keyword">@IBOutlet private weak var</span> label: <span class="type">UILabel</span>!
    <span class="keyword">@IBOutlet private weak var</span> infoLabel: <span class="type">UILabel</span>!
    
    <span class="comment">// MARK: - Actions</span>
    
    <span class="keyword">@IBAction func</span> increment() {
        model.<span class="call">increment</span>()
    }
    
    <span class="keyword">@IBAction func</span> decrement() {
        model.<span class="call">decrement</span>()
    }
    
    <span class="comment">// MARK: - Private</span>
    
    <span class="keyword">private func</span> bind(<span class="keyword">_</span> view: <span class="type">UIView</span>) {
        model.<span class="property">$value</span>
            .<span class="call">sink</span> { [<span class="keyword">weak self</span>] count <span class="keyword">in
                guard let self else</span> { <span class="keyword">return</span> }
                <span class="keyword">self</span>.<span class="property">label</span>.<span class="property">text</span> = <span class="string">"</span>\(count)<span class="string">"</span>
                <span class="keyword">self</span>.<span class="property">infoLabel</span>.<span class="property">text</span> = count.<span class="call">isMultiple</span>(of: <span class="number">2</span>) ? <span class="string">"Even"</span> : <span class="string">"Odd"</span>
                <span class="keyword">self</span>.<span class="property">label</span>.<span class="property">textColor</span> = <span class="keyword">switch</span> count {
                    <span class="keyword">case</span> <span class="number">0</span>:    .<span class="dotAccess">black</span>
                    <span class="keyword">case</span> <span class="number">1</span>...: <span class="type">UIColor</span>(red: <span class="number">0.1</span>, green: <span class="number">0.7</span>, blue: <span class="number">0.05</span>, alpha: <span class="number">1</span>)
                    <span class="keyword">default</span>:   .<span class="dotAccess">red</span>
                }
                <span class="keyword">self</span>.<span class="call">animateLabel</span>()
            }
            .<span class="call">store</span>(in: &amp;cancellables)
    }
    
    <span class="keyword">private func</span> animateLabel() {
        <span class="type">UIView</span>.<span class="call">animate</span>(withDuration: <span class="number">0.1</span>) {
            <span class="keyword">self</span>.<span class="property">label</span>.<span class="property">transform</span> = <span class="type">CGAffineTransform</span>(scaleX: <span class="number">1.3</span>, y: <span class="number">1.3</span>)
        } completion: { <span class="keyword">_ in</span>
            <span class="type">UIView</span>.<span class="call">animate</span>(withDuration: <span class="number">0.1</span>) {
                <span class="keyword">self</span>.<span class="property">label</span>.<span class="property">transform</span> = .<span class="dotAccess">identity</span>
            }
        }
    }
}
</code></pre><p>Admittedly, this may not look too bad, but we are dealing with a tiny demo example. In real-world scenarios, the complexity of view controllers can get out of control pretty quickly. Let's pick a well-known architectural pattern to simplify our code: MVVM (Model-View-ViewModel).</p><h3>MVVM: Extract Model Code</h3><p>A ViewModel provides properties with data to be displayed by the view. The view should observe changes to stay up-to-date, which makes Combine <code>Publisher</code>s a great choice:</p><pre><code><span class="keyword">final class</span> ViewModel {
    <span class="keyword">private let</span> model = <span class="type">Dependencies</span>.<span class="property">model</span>
    
    <span class="comment">// MARK: - View Properties</span>
    <span class="keyword">lazy private(set) var</span> value = model.<span class="property">$value</span>.<span class="call">map</span> { <span class="string">"</span>\($0)<span class="string">"</span> }
    <span class="keyword">lazy private(set) var</span> info = model.<span class="property">$value</span>.<span class="call">map</span>(infoText)
    <span class="keyword">lazy private(set) var</span> labelColor = model.<span class="property">$value</span>.<span class="call">map</span>(color)
}
</code></pre><p>We implement two action methods for handling user input:</p><pre><code><span class="comment">// MARK: - Actions</span>
<span class="keyword">extension</span> <span class="type">ViewModel</span> {
    <span class="keyword">func</span> increment() {
        model.<span class="call">increment</span>()
    }
    
    <span class="keyword">func</span> decrement() {
        model.<span class="call">decrement</span>()
    }
}
</code></pre><p>Finally, we add a private extension with value mappings for the previously declared <code>info</code> and <code>labelColor</code> properties:</p><pre><code><span class="keyword">private extension</span> <span class="type">ViewModel</span> {
    <span class="keyword">func</span> infoText(for count: <span class="type">Int</span>) -&gt; <span class="type">String</span> {
        count.<span class="call">isMultiple</span>(of: <span class="number">2</span>) ? <span class="string">"Even"</span> : <span class="string">"Odd"</span>
    }
    
    <span class="comment">// Here we actually leak styling-related code into our ViewModel. We
    // should not prescribe color values, but let's run with it for now...</span>
    <span class="keyword">func</span> color(for count: <span class="type">Int</span>) -&gt; <span class="type">UIColor</span> {
        <span class="keyword">switch</span> count {
            <span class="keyword">case</span> <span class="number">0</span>:    .<span class="dotAccess">black</span>
            <span class="keyword">case</span> <span class="number">1</span>...: .<span class="dotAccess">green</span>
            <span class="keyword">default</span>:   .<span class="dotAccess">red</span>
        }
    }
}
</code></pre><p>Our updated ViewController:</p><pre><code><span class="keyword">class</span> CounterViewController: <span class="type">UIViewController</span> {
    <span class="keyword">@IBOutlet private weak var</span> label: <span class="type">UILabel</span>!
    <span class="keyword">@IBOutlet private weak var</span> infoLabel: <span class="type">UILabel</span>!
    
    <span class="keyword">let</span> viewModel = <span class="type">ViewModel</span>()
    <span class="keyword">private var</span> cancellables: <span class="type">Set</span>&lt;<span class="type">AnyCancellable</span>&gt; = []
    
    <span class="keyword">override func</span> viewDidLoad() {
        <span class="keyword">super</span>.<span class="call">viewDidLoad</span>()
        <span class="call">bind</span>(view)
    }
    
    <span class="keyword">@IBAction func</span> increment() {
        viewModel.<span class="call">increment</span>()
    }
    
    <span class="keyword">@IBAction func</span> decrement() {
        viewModel.<span class="call">decrement</span>()
    }
    
    <span class="keyword">private func</span> bind(<span class="keyword">_</span> view: <span class="type">UIView</span>) {
        viewModel.<span class="property">value</span>.<span class="call">sink</span> { [<span class="keyword">weak self</span>] count <span class="keyword">in
            self</span>?.<span class="property">label</span>.<span class="property">text</span> = count
            <span class="keyword">self</span>?.<span class="call">animateLabel</span>()
        }.<span class="call">store</span>(in: &amp;cancellables)
        
        viewModel.<span class="property">info</span>.<span class="call">sink</span> { [<span class="keyword">weak self</span>] info <span class="keyword">in
            self</span>?.<span class="property">infoLabel</span>.<span class="property">text</span> = info
        }.<span class="call">store</span>(in: &amp;cancellables)
        
        viewModel.<span class="property">labelColor</span>.<span class="call">sink</span> { [<span class="keyword">weak self</span>] color <span class="keyword">in
            self</span>?.<span class="property">label</span>.<span class="property">textColor</span> = color
        }.<span class="call">store</span>(in: &amp;cancellables)
    }
    
    <span class="keyword">private func</span> animateLabel() {
        <span class="type">UIView</span>.<span class="call">animate</span>(withDuration: <span class="number">0.1</span>) {
            <span class="keyword">self</span>.<span class="property">label</span>.<span class="property">transform</span> = <span class="type">CGAffineTransform</span>(scaleX: <span class="number">1.3</span>, y: <span class="number">1.3</span>)
        } completion: { <span class="keyword">_ in</span>
            <span class="type">UIView</span>.<span class="call">animate</span>(withDuration: <span class="number">0.1</span>) {
                <span class="keyword">self</span>.<span class="property">label</span>.<span class="property">transform</span> = .<span class="dotAccess">identity</span>
            }
        }
    }
}
</code></pre><h3>MVVM: Extract View Code</h3><p>Maybe the improvement in code size is a bit disappointing. In fact, there is quite a bit of <em>View</em> code left over. We move the <code>animateLabel</code> method into a new <code>UIView</code> subclass and add properties for the values to be displayed:</p><pre><code><span class="keyword">final class</span> CounterView: <span class="type">UIView</span> {
    <span class="keyword">@IBOutlet private weak var</span> label: <span class="type">UILabel</span>!
    <span class="keyword">@IBOutlet private weak var</span> infoLabel: <span class="type">UILabel</span>!
    
    <span class="keyword">var</span> count: <span class="type">String</span>? {
        <span class="keyword">get</span> { label.<span class="property">text</span> }
        <span class="keyword">set</span> {
            label.<span class="property">text</span> = newValue
            <span class="call">animateLabel</span>()
        }
    }
    
    <span class="keyword">var</span> info: <span class="type">String</span>? {
        <span class="keyword">get</span> { infoLabel.<span class="property">text</span> }
        <span class="keyword">set</span> { infoLabel.<span class="property">text</span> = newValue }
    }
    
    <span class="keyword">var</span> textColor: <span class="type">UIColor</span>? {
        <span class="keyword">get</span> { label.<span class="property">textColor</span> }
        <span class="keyword">set</span> { label.<span class="property">textColor</span> = newValue }
    }
    
    <span class="keyword">private func</span> animateLabel() {
        <span class="type">UIView</span>.<span class="call">animate</span>(withDuration: <span class="number">0.1</span>) {
            <span class="keyword">self</span>.<span class="property">label</span>.<span class="property">transform</span> = <span class="type">CGAffineTransform</span>(scaleX: <span class="number">1.3</span>, y: <span class="number">1.3</span>)
        } completion: { <span class="keyword">_ in</span>
            <span class="type">UIView</span>.<span class="call">animate</span>(withDuration: <span class="number">0.1</span>) {
                <span class="keyword">self</span>.<span class="property">label</span>.<span class="property">transform</span> = .<span class="dotAccess">identity</span>
            }
        }
    }
}
</code></pre><p>We update the ViewController to use the custom view:</p><pre><code><span class="keyword">class</span> CounterViewController: <span class="type">UIViewController</span> {
    <span class="keyword">@IBOutlet private weak var</span> counterView: <span class="type">CounterView</span>!
    
    <span class="keyword">let</span> viewModel = <span class="type">ViewModel</span>()
    <span class="keyword">private var</span> cancellables: <span class="type">Set</span>&lt;<span class="type">AnyCancellable</span>&gt; = []
    
    <span class="keyword">override func</span> viewDidLoad() {
        <span class="keyword">super</span>.<span class="call">viewDidLoad</span>()
        <span class="call">bind</span>(view)
    }
    
    <span class="keyword">@IBAction func</span> increment() {
        viewModel.<span class="call">increment</span>()
    }
    
    <span class="keyword">@IBAction func</span> decrement() {
        viewModel.<span class="call">decrement</span>()
    }
    
    <span class="keyword">private func</span> bind(<span class="keyword">_</span> view: <span class="type">UIView</span>) {
        viewModel.<span class="property">value</span>.<span class="call">sink</span> { [<span class="keyword">weak</span> counterView] count <span class="keyword">in</span>
            counterView?.<span class="property">count</span> = count
        }.<span class="call">store</span>(in: &amp;cancellables)
        
        viewModel.<span class="property">info</span>.<span class="call">sink</span> { [<span class="keyword">weak</span> counterView] info <span class="keyword">in</span>
            counterView?.<span class="property">info</span> = info
        }.<span class="call">store</span>(in: &amp;cancellables)
        
        viewModel.<span class="property">labelColor</span>.<span class="call">sink</span> { [<span class="keyword">weak</span> counterView] color <span class="keyword">in</span>
            counterView?.<span class="property">textColor</span> = color
        }.<span class="call">store</span>(in: &amp;cancellables)
    }
}
</code></pre><p>Our ViewController has been simplified quite nicely now. However, the current version is chock-full of silly boilerplate code that does not do anything. We just observe changes in the <code>viewModel</code> and pass them on to the <code>view</code>. And we receive actions from the <code>view</code> and pass them on to the <code>viewModel</code>. This class does not provide any value at this point. Unfortunately, we cannot fix it... yet.</p><h3>Remove Boilerplate</h3><p>The boilerplate code in the <code>ViewController</code> adds a layer of separation between <code>counterView</code> and <code>viewModel</code>. This is redundant; the role of separating view from model is already provided by the <code>viewModel</code>. It would be nice to remove the ceremony and connect <code>counterView</code> directly to <code>viewModel</code>. There is actually a tool for this purpose: Custom storyboard objects. They are implemented as classes deriving from <code>NSObject</code>. We can add <code>@IBOutlet</code> and <code>@IBAction</code> annotations for storyboard connections.</p><p>For this demo, let's split the <code>ViewModel</code> into two classes. We could keep the <code>ViewModel</code> intact, but splitting it demonstrates a different architectural approach where data flows only in one direction. And the split approach illustrates how to use multiple custom objects in a storyboard.</p><p>The first object is the <code>Presenter</code>, providing current state for the view to display. Data flows unidirectionally from the Model to the View:</p><pre><code><span class="keyword">class</span> Presenter: <span class="type">NSObject</span> {
    <span class="keyword">let</span> model = <span class="type">Dependencies</span>.<span class="property">model</span>
    
    <span class="keyword">@IBOutlet weak var</span> view: <span class="type">CounterViewProtocol</span>? {
        <span class="keyword">didSet</span> {
            <span class="keyword">guard let</span> view <span class="keyword">else</span> { <span class="keyword">return</span> }
            <span class="call">bind</span>(view)
        }
    }
    
    <span class="keyword">lazy private(set) var</span> value = model.<span class="property">$value</span>.<span class="call">map</span> { <span class="string">"</span>\($0)<span class="string">"</span> }
    <span class="keyword">lazy private(set) var</span> info = model.<span class="property">$value</span>.<span class="call">map</span>(infoText)
    <span class="keyword">lazy private(set) var</span> labelColor = model.<span class="property">$value</span>.<span class="call">map</span>(color)
    
    <span class="keyword">private func</span> bind(<span class="keyword">_</span> view: <span class="type">CounterViewProtocol</span>) {
        value.<span class="call">sink</span> { [<span class="keyword">weak</span> view] value <span class="keyword">in</span>
            view?.<span class="property">count</span> = value
        }.<span class="call">store</span>(in: &amp;cancellables)
        
        info.<span class="call">sink</span> { [<span class="keyword">weak</span> view] info <span class="keyword">in</span>
            view?.<span class="property">info</span> = info
        }.<span class="call">store</span>(in: &amp;cancellables)
        
        labelColor.<span class="call">sink</span> { [<span class="keyword">weak</span> view] color <span class="keyword">in</span>
            view?.<span class="property">textColor</span> = color
        }.<span class="call">store</span>(in: &amp;cancellables)
    }
    
    <span class="keyword">func</span> infoText(for count: <span class="type">Int</span>) -&gt; <span class="type">String</span> {
        count.<span class="call">isMultiple</span>(of: <span class="number">2</span>) ? <span class="string">"Even"</span> : <span class="string">"Odd"</span>
    }
    
    <span class="keyword">func</span> color(for count: <span class="type">Int</span>) -&gt; <span class="type">CounterColor</span> {
        <span class="keyword">switch</span> count {
        <span class="keyword">case</span> <span class="number">0</span>:    .<span class="dotAccess">zero</span>
        <span class="keyword">case</span> <span class="number">1</span>...: .<span class="dotAccess">positive</span>
        <span class="keyword">default</span>:   .<span class="dotAccess">negative</span>
        }
    }
    
    <span class="keyword">private var</span> cancellables: <span class="type">Set</span>&lt;<span class="type">AnyCancellable</span>&gt; = []
}
</code></pre><p>The <code>view</code> property is connected to the view in the storyboard via an <code>@IBOutlet</code>. In this case, we don't work with the concrete view class. Instead, the following <code>CounterViewProtocol</code> provides an interface:</p><pre><code><span class="keyword">@objc protocol</span> CounterViewProtocol {
    <span class="keyword">var</span> count: <span class="type">String</span>? { <span class="keyword">get set</span> }
    <span class="keyword">var</span> info: <span class="type">String</span>? { <span class="keyword">get set</span> }
    <span class="keyword">var</span> textColor: <span class="type">CounterColor</span> { <span class="keyword">get set</span> }
}
</code></pre><p>The second class is the <code>Interactor</code>. It receives <code>@IBActions</code> from the view, performs some business logic, and updates the model. Data flows unidirectionally from the view to the model.</p><pre><code><span class="keyword">class</span> Interactor: <span class="type">NSObject</span> {
    <span class="keyword">let</span> model = <span class="type">Dependencies</span>.<span class="property">model</span>
    
    <span class="keyword">@IBAction func</span> increment() {
        <span class="comment">// OK, not a lot of business logic here...</span>
        model.<span class="call">increment</span>()
    }
    
    <span class="keyword">@IBAction func</span> decrement() {
        model.<span class="call">decrement</span>()
    }
}
</code></pre><p>Now we can remove the ViewController boilerplate.<br/> ü•Å <em>drum roll</em> ü•Å<br/> Behold the magnificence of this mighty massive controller:</p><pre><code><span class="keyword">class</span> CounterViewController: <span class="type">UIViewController</span> { }
</code></pre><p>Yes, this is all the controller code needed for this demo app. In fact, we could use a <code>UIViewController</code> instance directly instead of a subclass, but having a separate type for each scene may be useful when debugging.</p><h3>Storyboard Update</h3><p>Before we can test our new code, we need to update the storyboard. First, remove any existing outlet and action connections.</p><h4>Step 1: Set Custom Class of the View</h4><p>By default, the <code>view</code> of a viewController is a <code>UIView</code> instance. We want to make sure that our customized <code>CounterView</code> is created when the view loads. We can do this by setting the custom class in the view's Identity Inspector:</p><img src="https://saiboi.com/blog/simplifiedViewController/customViewClass.png" alt="Set Custom Class in Xcode's Identity Inspector"/><h4>Step 2: Add Custom Objects</h4><p>Drag an <code>Object</code> from the <code>Views Library</code> into your scene. Make sure it is selected. Set the custom <code>Class</code> to <code>Presenter</code> in the <code>Identity Inspector</code>. Repeat this process for the <code>Interactor</code>.</p><img src="https://saiboi.com/blog/simplifiedViewController/viewsLibrary.png" alt="Search for "Object" in Xcode's Views Library"/><h4>Step 3: Connect Outlets</h4><p>Drag an outlet connection from <code>Presenter.view</code> to the <code>CounterView</code>. Connect the <code>label</code> and <code>infoLabel</code> outlets in <code>CounterView</code> to the labels in the storyboard.</p><img src="https://saiboi.com/blog/simplifiedViewController/presenterViewOutlet.png" alt="Search for "Object" in Xcode's Views Library"/><h4>Step 4: Connect Actions</h4><p>Establish the connections between buttons and the <code>Interactor</code>'s <code>@IBAction</code> methods.</p><img src="https://saiboi.com/blog/simplifiedViewController/interactorAction.png" alt="Search for "Object" in Xcode's Views Library"/><p>Build and run!</p><h2>Conclusion</h2><p>Custom Objects in storyboards are a powerful tool to dramatically simplify view controllers. We can connect view models, or interactors and presenters as shown in this demo. Custom objects are created automatically when the scene is loaded from its storyboard. However, this only works for classes with an initializer without any parameters. Any dependencies must be provided by some other means.</p><p>Nib/Xib files for views have an interesting additional feature: Proxy Objects. These are not instantiated automatically when loading the view. We have to manually create these objects and provide them in the <code>options</code> dictionary when loading the nib. This way we have all the freedom to create and configure objects as needed. However, the dictionary-based API is very clunky; see <a href="https://developer.apple.com/documentation/uikit/uinib/instantiate(withowner:options:)" rel="nofollow" target="blank">UINib.instantiate(withOwner:options:)</a>.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://saiboi.com/blog/Labels%20in%20Switch%20Patterns</guid><title>Labels for Switch Patterns</title><description>How to make switching over multiple values more readable.</description><link>https://saiboi.com/blog/Labels%20in%20Switch%20Patterns</link><pubDate>Fri, 7 Mar 2025 16:40:00 +0100</pubDate><content:encoded><![CDATA[<h1>Labels for Switch Patterns</h1><p>We frequently come across scenarios where we need to check multiple values before executing conditional code. These can lead to nested <code>if</code> statements, which are potentially hard to read and maintain. <code>switch</code> statements are a great alternative with multiple advantages: The compiler performs exhaustiveness checking, and powerful pattern matching is more natural than using the rather weird <code>if case</code> syntax. Additionally, a <code>switch</code> statement can be more efficient than chaining multiple conditionals, as the value to be switched over is read once only, unlike once for each individual <code>if</code> condition check.</p><p>It is important to remember that the switch is evaluated in sequential order until a match is found. By strategically ordering the most specific cases at the top, and the more general catch-all cases at the bottom, we can implement some powerful logic in a simple and concise manner. In the following example, we add the most general case where the <code>isAdmin</code> condition is irrelevant at the bottom:</p><pre><code><span class="keyword">switch</span> (isLoggedIn, isAdmin) {
<span class="keyword">case</span> (<span class="keyword">true</span>, <span class="keyword">true</span>):
    <span class="comment">// ...</span>
    
<span class="keyword">case</span> (<span class="keyword">true</span>, <span class="keyword">false</span>):
    <span class="comment">// ...</span>
    
<span class="keyword">case</span> (<span class="keyword">false</span>, <span class="keyword">_</span>):
    <span class="comment">// For logged-out users, we don't care whether they are an admin.</span>
}
</code></pre><p>Great, this works! But let's face it, it's hard to read. Of course, we can figure out what "<code>case (true, false):</code>" in the above example means, but we have to cross-reference the tuple at the top of the <code>switch</code> statement.</p><p>Let's refactor to improve readability. A very powerful tool is to use bespoke <em>types</em> in place of nondescript <code>true</code>/<code>false</code> boolean values. Here is our example rewritten with two <code>enum</code> types specific for each use case:</p><pre><code><span class="keyword">enum</span> SessionState {
  <span class="keyword">case</span> loggedIn, loggedOut
}

<span class="keyword">enum</span> Role {
  <span class="keyword">case</span> admin, user
}

<span class="comment">// elsewhere:</span>

<span class="keyword">switch</span> (sessionState, role) {
<span class="keyword">case</span> (.<span class="dotAccess">loggedIn</span>, .<span class="dotAccess">admin</span>):
    <span class="comment">// do admin stuff</span>

<span class="keyword">case</span> (.<span class="dotAccess">loggedIn</span>, <span class="keyword">_</span>):
    <span class="comment">// do non-admin stuff</span>

<span class="keyword">case</span> (.<span class="dotAccess">loggedOut</span>, <span class="keyword">_</span>):
    <span class="comment">// ask user to log in</span>
</code></pre><p>Nice! Now our code is locally glanceable. Of course, it may be a bit overkill to do this everywhere. Before we look at a more lightweight approach, it's important to consider additional benefits of custom types. When using a boolean <code>isAdmin</code> value, we could later accidentally replace it with some unrelated boolean value, such as <code>isGuestUser</code>. The compiler is happy with this change, and suddenly all guest users are allowed to perform Admin tasks. Oops! With a bespoke <code>Role</code> type, we get compiler errors preventing this bug. Additionally, a boolean value always has exactly two states, which makes it harder to introduce a new role for guest users. But it's easy with our <code>Role</code> type: we just add a new <code>.guest</code> case.</p><p>However, it may be overkill to define custom types if we only use them for a single switch. A more lightweight approach is to use <strong>labels</strong> instead. Let's see how they can provide similar readability benefits:</p><pre><code><span class="keyword">switch</span> (loggedIn: isLoggedIn, isAdmin: isAdmin) {
<span class="keyword">case</span> (loggedIn: <span class="keyword">true</span>, isAdmin: <span class="keyword">true</span>):
    <span class="comment">// do admin stuff</span>
    
<span class="keyword">case</span> (loggedIn: <span class="keyword">true</span>, isAdmin: <span class="keyword">false</span>):
    <span class="comment">// do non-admin stuff</span>
    
<span class="keyword">case</span> (loggedIn: <span class="keyword">false</span>, <span class="keyword">_</span>):
    <span class="comment">// ask user to log in</span>
}
</code></pre><p>Notice how we don't have to write the label for the catch-all underscore pattern in the third <code>case</code>. Of course, we can mix and match the two approaches as needed. In this example, I would probably prefer a custom <code>Role</code> type, and use a label for a boolean <code>loggedIn</code> state.</p>]]></content:encoded></item></channel></rss>